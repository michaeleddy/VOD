using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using VOD.Lib;
using VOD.Lib.Libs;
using VOD.Lib.Models;

namespace VOD
{
    public sealed class Danmaku : IDisposable
    {
        private int RoomId { get; }
        private string[] DefaultHosts { get; } = new string[] { "livecmt-2.bilibili.com", "livecmt-1.bilibili.com" };
        private string ChatHost = "chat.bilibili.com";
        private int ChatPort { get; set; } = 2243;
        private TcpClient TcpClient { get; }
        private MusicClient MusicClient { get; }
        private Stream NetStream { get; set; }
        private bool Connected { get; set; } = false;
        private HttpClient HttpClient { get; }
        private List<MusicModel> MusicList { get; }
        public delegate void PlaySongEvent(object sender, EventModel e);
        public event PlaySongEvent PlaySongEvt;
        public delegate void PrintEvent(object sender, EventModel e);
        public event PrintEvent PrintEvt;
        public Danmaku(List<MusicModel> musicList)
        {
            MusicList = musicList;
            RoomId = "roomid".GetConfig().ToInt32();
            TcpClient = new TcpClient();
            HttpClient = new HttpClient { Timeout = TimeSpan.FromSeconds(5) };
            MusicClient = new MusicClient(HttpClient);
        }
        public async Task<bool> ConnectAsync()
        {
            try
            {
                var token = "";
                try
                {
                    var req = await HttpClient.GetStringAsync("https://api.live.bilibili.com/room/v1/Danmu/getConf?room_id=" + RoomId);
                    var roomobj = JObject.Parse(req);
                    token = roomobj["data"]["token"].ToString();
                    ChatHost = roomobj["data"]["host"].ToString();
                    ChatPort = roomobj["data"]["port"].Value<int>();
                    if (string.IsNullOrEmpty(ChatHost))
                        throw new Exception();
                }
                catch
                {
                    ChatHost = DefaultHosts[new Random().Next(DefaultHosts.Length)];
                }
                var ipaddrss = await Dns.GetHostAddressesAsync(ChatHost);
                var random = new Random();
                var idx = random.Next(ipaddrss.Length);
                await TcpClient.ConnectAsync(ipaddrss[idx], ChatPort);
                NetStream = Stream.Synchronized(TcpClient.GetStream());
                if (await SendJoinChannel(RoomId, token))
                {
                    Connected = true;
                    _ = HeartbeatLoop();
                    _ = ReceiveMessageLoop();
                    return true;
                }
                return false;
            }
            catch { return false; }
        }
        private async Task ReceiveMessageLoop()
        {
            try
            {
                var stableBuffer = new byte[16];
                var buffer = new byte[4096];
                while (this.Connected)
                {
                    await NetStream.ReadBAsync(stableBuffer, 0, 16);
                    var protocol = DanmakuProtocol.FromBuffer(stableBuffer);
                    if (protocol.PacketLength < 16)
                        throw new NotSupportedException("协议失败: (L:" + protocol.PacketLength + ")");
                    var payloadlength = protocol.PacketLength - 16;
                    if (payloadlength == 0) continue;
                    buffer = new byte[payloadlength];
                    await NetStream.ReadBAsync(buffer, 0, payloadlength);
                    if (protocol.Version == 2 && protocol.Action == 5)
                    {
                        using (var ms = new MemoryStream(buffer, 2, payloadlength - 2))
                        using (var deflate = new DeflateStream(ms, CompressionMode.Decompress))
                        {
                            var headerbuffer = new byte[16];
                            try
                            {
                                while (true)
                                {
                                    await deflate.ReadBAsync(headerbuffer, 0, 16);
                                    var protocol_in = DanmakuProtocol.FromBuffer(headerbuffer);
                                    payloadlength = protocol_in.PacketLength - 16;
                                    var danmakubuffer = new byte[payloadlength];
                                    await deflate.ReadBAsync(danmakubuffer, 0, payloadlength);
                                    ProcessDanmaku(protocol.Action, danmakubuffer);
                                }
                            }
                            catch { }
                        }
                    }
                    else
                    {
                        ProcessDanmaku(protocol.Action, buffer);
                    }
                }
            }
            catch { Disconnect(); }
        }
        private void ProcessDanmaku(int action, byte[] buffer)
        {
            switch (action)
            {
                case 5:
                    {
                        var json = Encoding.UTF8.GetString(buffer, 0, buffer.Length);
                        try
                        {
                            var dama = new DanmakuModel(json, 2);
                            switch (dama.MsgType)
                            {
                                case MsgTypeEnum.Comment:
                                    {
                                        var model = new EventModel();
                                        if (dama.CommentText.StartsWith("#点歌"))
                                        {
                                            var values = dama.CommentText.Replace("#点歌", "").Split(' ');
                                            var sv = values.Where(x => !string.IsNullOrEmpty(x));
                                            var musicInfo = MusicClient.GetSongList(sv);
                                            model.SongChoser = dama.UserName;
                                            if (musicInfo.ErrorMsg.IsNotEmpty())
                                            {
                                                model.PrintMsg = string.Format("用户：{0} 点歌：{1} 失败,可能原因：{2}", dama.UserName, dama.CommentText, musicInfo.ErrorMsg);
                                                PrintEvt?.Invoke(this, model);
                                            }
                                            else
                                            {
                                                MusicList.Add(musicInfo);
                                                model.PrintMsg = string.Format("用户：{0} 点歌：{1} 成功，加入队列中", dama.UserName, dama.CommentText);
                                                model.MusicInfo = musicInfo;
                                                PlaySongEvt?.Invoke(this, model);
                                            }
                                        }
                                        else
                                        {
                                            model.PrintMsg = string.Format("用户：{0} 发送了一条弹幕：{1}", dama.UserName, dama.CommentText);
                                        }
                                        break;
                                    }
                                case MsgTypeEnum.GiftSend:
                                    {
                                        var model = new EventModel
                                        {
                                            PrintMsg = string.Format("谢谢{0}赠送的{1}个{2}，{3}表示灰常喜欢，么么哒~", dama.UserName, dama.GiftCount, dama.GiftName, "name".GetConfig()),
                                            DateTime = DateTime.Now
                                        };
                                        PlaySongEvt?.Invoke(this, model);
                                        break;
                                    }
                            }
                        }
                        catch { }
                        break;
                    }
            }
        }
        private async Task HeartbeatLoop()
        {

            try
            {
                while (Connected)
                {
                    await SendHeartbeatAsync();
                    await Task.Delay(30000);
                }
            }
            catch { Disconnect(); }
        }
        public void Disconnect()
        {
            if (Connected)
            {
                Connected = false;
                TcpClient.Close();
                NetStream = null;
            }
        }
        private async Task SendHeartbeatAsync()
        {
            await SendSocketDataAsync(2);
        }
        Task SendSocketDataAsync(int action, string body = "")
        {
            return SendSocketDataAsync(0, 16, 2, action, 1, body);
        }
        async Task SendSocketDataAsync(int packetlength, short magic, short ver, int action, int param = 1, string body = "")
        {
            var playload = Encoding.UTF8.GetBytes(body);
            if (packetlength == 0)
                packetlength = playload.Length + 16;
            var buffer = new byte[packetlength];
            using (var ms = new MemoryStream(buffer))
            {
                var b = EndianBitConverter.BigEndian.GetBytes(buffer.Length);
                await ms.WriteAsync(b, 0, 4);
                b = EndianBitConverter.BigEndian.GetBytes(magic);
                await ms.WriteAsync(b, 0, 2);
                b = EndianBitConverter.BigEndian.GetBytes(ver);
                await ms.WriteAsync(b, 0, 2);
                b = EndianBitConverter.BigEndian.GetBytes(action);
                await ms.WriteAsync(b, 0, 4);
                b = EndianBitConverter.BigEndian.GetBytes(param);
                await ms.WriteAsync(b, 0, 4);
                if (playload.Length > 0)
                    await ms.WriteAsync(playload, 0, playload.Length);
                await NetStream.WriteAsync(buffer, 0, buffer.Length);
            }
        }
        private async Task<bool> SendJoinChannel(int channelId, string token)
        {
            var packetModel = new { roomid = channelId, uid = 0, protover = 2, token, platform = "danmuji" };
            var playload = JsonConvert.SerializeObject(packetModel);
            await SendSocketDataAsync(7, playload);
            return true;
        }
        public void Dispose()
        {
            try
            {
                HttpClient.Dispose();
                Disconnect();
            }
            catch { }
        }
    }
}